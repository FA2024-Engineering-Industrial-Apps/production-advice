"""
This script is designed to optimize the grouping of Printed Circuit Boards (PCBs) based on their material requirements
and slot widths using a hybrid brute forcing optimization algorithm. It generates optimal valid combinations
while adhering to a maximum slot width constraint (C_max).
"""
import pandas as pd
import json

def is_valid_group(group, pcb_data_dict, material_catalogue_dict, C_max):
    '''
    This function checks if a group of PCBs is valid based on their total required slot width.

    :param group: List of PCB identifiers forming a group.
    :param pcb_data_dict: Dictionary with PCB identifiers as keys and lists of required materials as values.
    :param material_catalogue_dict: Dictionary with material identifiers as keys and their respective slot widths as values.
    :param C_max: Maximum allowed slot width for any group.
    :return: True if the group is valid, otherwise False.
    '''


    if len(group) == 1:    # a group consisting of only one PCB is always valid
        return True

    used_material = set()  # set to keep track of materials already counted
    total_capacity = 0

    for pcb in group:      # iterating over each PCB in the group

        for material in pcb_data_dict[pcb]:             # iterating over the materials required by the PCB

            if material not in used_material:            # only add new materials that haven't been counted yet

                used_material.add(material)
                total_capacity += material_catalogue_dict[material]
                if total_capacity > C_max:                # if total capacity exceeds the allowed maximum, the group is invalid

                    return False

    return True                                            # if the total capacity is within the allowed maximum, the group is valid


def generate_combinations(pcbs, pcb_data_dict, material_catalogue_dict, C_max):
    '''
    This function generates combinations of PCBs based on their total required slot width.
    It aims to find the minimum number of groups such that the combined slot width of PCBs in each group does not exceed C_max.

    :param pcbs: List of PCB identifiers to be grouped.
    :param pcb_data_dict: Dictionary with PCB identifiers as keys and their respective materials as values.
    :param material_catalogue_dict: Dictionary with material identifiers as keys and their respective slot widths as values.
    :param C_max: Maximum allowed slot width for any group.
    :param current_groups: List of current groups of PCBs being formed. Defaults to an empty list.
    '''

    # https://stackoverflow.com/a/30134039/8302811
    if len(pcbs) == 1:
        if is_valid_group([pcbs], pcb_data_dict, material_catalogue_dict, C_max):
            yield [pcbs]
        return
    
    first = pcbs[0]
    for other_partition in generate_combinations(pcbs[1:], pcb_data_dict, material_catalogue_dict, C_max):
        for i in range(len(other_partition)):
            if is_valid_group([first, *other_partition[i]], pcb_data_dict, material_catalogue_dict, C_max):
                yield [*other_partition[:i], [first, *other_partition[i]], *other_partition[i+1:]]
        if is_valid_group([first], pcb_data_dict, material_catalogue_dict, C_max):
            yield [[first], *other_partition]
    

def call(pcb_indecies: list[int]):
    C_max = 15  # maximum slot size
    dataset_path = "./50_entry_dataset/"  # path to dataset
    material_catalogue_path = f"{dataset_path}Material_catalogue.csv"  # path to csv file of Material_catelogue
    material_catalogue = pd.read_csv(material_catalogue_path)  # read csv file of Material_catelogue
    material_catalogue = material_catalogue.to_numpy()
    material_catalogue = material_catalogue[:, :2]
    material_catalogue_dict = {key: value for key, value in
                               material_catalogue}  # setup dictonary of materials ( key: Material Index , value: Slot Width ) using Material_catelogue
    pcb_data_dict = {}
    pcb_files = [f"{dataset_path}PCB{i:03d}.csv" for i in pcb_indecies]
    for pcb_number, each_file in zip(pcb_indecies, pcb_files):  # read every PCBs in pcb_files
        pcb = pd.read_csv(each_file)
        pcb_data_dict[f'PCB{pcb_number:03d}'] = pcb[
            "Material Index"].values  # preparing dictionary of PCBs (key: Name of PCB, value: Material Index)
    pcb_list = list(pcb_data_dict.keys())  # list of all PCBs
    pcb_list = sorted(pcb_list, key=lambda x: sum(material_catalogue_dict[key] for key in pcb_data_dict[x]),reverse=True)  # sorting PCBS basing on their total slot width in descending order
    # -----------------------------------------------------
    # Generating Combinations
    best_combinations = []        # initialize a list to store the best combinations
    min_comb_len = float('inf')
    for combination in generate_combinations(pcb_list, pcb_data_dict, material_catalogue_dict, C_max):            # iterate over each valid combination generated by the generate_combinations function
        if len(combination) == min_comb_len:    # if the current combination has the same number of groups as the minimum, add it to the best_combinations list
            best_combinations.append(combination)
        elif len(combination) < min_comb_len:    # if the current combination has fewer groups than the previously found minimum, update the minimum and clear the best_combinations list
            min_comb_len = len(combination)
            best_combinations = [combination]
        else:
            break
    
    return best_combinations

# -----------------------------------------------------
if __name__ == "__main__":
    while True:
        inp = input(">>> ")
        indecies = [int(subs.strip()) for subs in inp.split(",")]
        print(json.dumps(call(indecies), indent=2))